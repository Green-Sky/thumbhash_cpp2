
// Generated by cppfront v0.7.3 build 9817:1821
#ifndef THUMBHASH_H_CPP2
#define THUMBHASH_H_CPP2


#include "cpp2util.h"


namespace thumbhash {

}

namespace thumbhash {

auto inline constexpr PI{ 3.14159'26535'89793'23846L };

struct scale_to_size_nn_ret { std::vector<cpp2::u8> out_img; cpp2::i32 out_w; cpp2::i32 out_h; };

// down-/upscale to ~100x100, keeping the aprox. ratio
[[nodiscard]] auto scale_to_size_nn(auto const& src_img, auto const& src_w, auto const& src_h) -> scale_to_size_nn_ret;
struct encode_channel_ret { float dc; std::vector<float> ac; float scale; };



[[nodiscard]] auto encode_channel(auto const& channel, auto const& w, auto const& h, auto const& nx, auto const& ny) -> encode_channel_ret;

[[nodiscard]] auto rgba_to_hash(cpp2::impl::in<std::span<cpp2::u8 const>> rgba, cpp2::impl::in<cpp2::i16> w, cpp2::impl::in<cpp2::i16> h) -> std::vector<cpp2::u8>;

// read the approx. aspect ratio from the hash
// returns 0.f on error
[[nodiscard]] auto hash_to_aspect_ratio(cpp2::impl::in<std::span<cpp2::u8 const>> hash) -> float;

} // thumbhash

namespace thumbhash {

[[nodiscard]] auto scale_to_size_nn(auto const& src_img, auto const& src_w, auto const& src_h) -> scale_to_size_nn_ret{
     cpp2::impl::deferred_init<std::vector<cpp2::u8>> out_img;
     cpp2::impl::deferred_init<cpp2::i32> out_w;
     cpp2::impl::deferred_init<cpp2::i32> out_h;
 out_img.construct(std::vector<cpp2::u8>());

 // resize to 100x100 (aprox, the longer size will be 100)
 auto const img_size {std::max(src_w, src_h)}; 
 out_w.construct(std::lround(100 * src_w / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(src_w),img_size)));
 out_h.construct(std::lround(100 * src_h / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(src_h),cpp2::move(img_size))));
 //out_img = std::vector<u8>(out_w * out_h * 4, 0xff);
 CPP2_UFCS(resize)(out_img.value(), out_w.value() * out_h.value() * 4, 0xff);

 // perform nn
 for ( auto const& dest_y : cpp2::range(0,out_h.value()) ) {
  for ( auto const& dest_x : cpp2::range(0,out_w.value()) ) {
   auto const sx {std::lround(float(dest_x) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(float(dest_x)),out_w.value()) * (src_w - 1))}; 
   auto const sy {std::lround(float(dest_y) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(float(dest_y)),out_h.value()) * (src_h - 1))}; 

   auto const src_pos {(cpp2::move(sx) * 4) + cpp2::move(sy) * src_w * 4}; 
   auto const dst_pos {(dest_x * 4) + dest_y * out_w.value() * 4}; 

   CPP2_ASSERT_IN_BOUNDS(out_img.value(), dst_pos + 0) = CPP2_ASSERT_IN_BOUNDS(src_img, src_pos + 0);
   CPP2_ASSERT_IN_BOUNDS(out_img.value(), dst_pos + 1) = CPP2_ASSERT_IN_BOUNDS(src_img, src_pos + 1);
   CPP2_ASSERT_IN_BOUNDS(out_img.value(), dst_pos + 2) = CPP2_ASSERT_IN_BOUNDS(src_img, src_pos + 2);
   CPP2_ASSERT_IN_BOUNDS(out_img.value(), dst_pos + 3) = CPP2_ASSERT_IN_BOUNDS(src_img, cpp2::move(src_pos) + 3);
  }
 }return  { std::move(out_img.value()), std::move(out_w.value()), std::move(out_h.value()) }; 
}

[[nodiscard]] auto encode_channel(auto const& channel, auto const& w, auto const& h, auto const& nx, auto const& ny) -> encode_channel_ret{
     cpp2::impl::deferred_init<float> dc;
 std::vector<float> ac {};
     cpp2::impl::deferred_init<float> scale;
 dc.construct(0.f);
 CPP2_UFCS(reserve)(ac, nx * ny / CPP2_ASSERT_NOT_ZERO_LITERAL(CPP2_TYPEOF(ny),2));
 scale.construct(0.f);

 auto fx {std::vector<float>(w, 0.f)}; 

 for ( auto const& cy : cpp2::range(0,ny) ) {
{
auto cx{0};

  for( ; (cpp2::impl::cmp_less(cx * ny,nx * (ny - cy))); ++cx ) {
   for ( auto const& x : cpp2::range(0,w) ) {
    // casting PI down to float here increases the similarity with the target hash
    CPP2_ASSERT_IN_BOUNDS(fx, x) = std::cos(float(PI) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(float(PI)),w) * cx * (x + 0.5f));
   }

   float f {0.f}; 
   for ( auto const& y : cpp2::range(0,h) ) {
    auto const fy {std::cos(float(PI) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(float(PI)),h) * cy * (y + 0.5f))}; 
    for ( auto const& x : cpp2::range(0,w) ) {
     f += CPP2_ASSERT_IN_BOUNDS(channel, x + y * w) * CPP2_ASSERT_IN_BOUNDS(fx, x) * fy;
    }
   }
   f /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(f),w * h);

   if ((cpp2::impl::cmp_greater(cx,0) || cpp2::impl::cmp_greater(cy,0))) {
    CPP2_UFCS(push_back)(ac, f);
    scale.value() = std::max(scale.value(), std::abs(cpp2::move(f)));
   }else {
    dc.value() = cpp2::move(f);
   }
  }
}
 }

 if ((cpp2::impl::cmp_greater(scale.value(),0))) {
  for ( auto& e : ac ) {
   e = 0.5f + 0.5f / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(0.5f),scale.value()) * e;
  }
 }return  { std::move(dc.value()), std::move(ac), std::move(scale.value()) }; 
}

[[nodiscard]] auto rgba_to_hash(cpp2::impl::in<std::span<cpp2::u8 const>> rgba, cpp2::impl::in<cpp2::i16> w, cpp2::impl::in<cpp2::i16> h) -> std::vector<cpp2::u8>{
 if (cpp2::cpp2_default.is_active() && !([_0 = 10, _1 = w, _2 = 100]{ return cpp2::impl::cmp_less_eq(_0,_1) && cpp2::impl::cmp_less_eq(_1,_2); }()) ) { cpp2::cpp2_default.report_violation(""); }
 if (cpp2::cpp2_default.is_active() && !([_0 = 10, _1 = h, _2 = 100]{ return cpp2::impl::cmp_less_eq(_0,_1) && cpp2::impl::cmp_less_eq(_1,_2); }()) ) { cpp2::cpp2_default.report_violation(""); }

 if (cpp2::cpp2_default.is_active() && !(CPP2_UFCS(size)(rgba) == w * h * 4) ) { cpp2::cpp2_default.report_violation(""); }

 // avg color
 auto avg_r {0.0f}; 
 auto avg_g {0.0f}; 
 auto avg_b {0.0f}; 
 auto avg_a {0.0f}; 
{
cpp2::i32 i{0};// not avg but sum

 for( ; cpp2::impl::cmp_less(i,CPP2_UFCS(ssize)(rgba)); i += 4 ) {
  auto pixel {CPP2_UFCS(subspan)(rgba, i, 4)}; 
  auto alpha {CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 3) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 3)),255.f)}; 
  avg_r += (CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 0) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 0)),255.f)) * alpha;
  avg_g += (CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 1) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 1)),255.f)) * alpha;
  avg_b += (CPP2_ASSERT_IN_BOUNDS_LITERAL(cpp2::move(pixel), 2) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(cpp2::move(pixel), 2)),255.f)) * alpha;
  avg_a += cpp2::move(alpha);
 }
}

 if (cpp2::impl::cmp_greater(avg_a,0.f)) {
  avg_r /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(avg_r),avg_a);
  avg_g /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(avg_g),avg_a);
  avg_b /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(avg_b),avg_a);
 }

 bool const has_alpha {cpp2::impl::cmp_less(cpp2::move(avg_a),w * h)}; 
 cpp2::impl::deferred_init<cpp2::i16 const> l_limit; 
 if (cpp2::move(has_alpha)) {
  l_limit.construct(5);
 }else {
  l_limit.construct(7);
 }

 cpp2::impl::deferred_init<cpp2::i16 const> longer_side; 
 if (cpp2::impl::cmp_greater_eq(w,h)) {
  longer_side.construct(w);
 }else {
  longer_side.construct(h);
 }

 auto const l_w {std::max<cpp2::i16>(1, cpp2::i16(std::lround(float(l_limit.value() * w) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(float(l_limit.value() * w)),longer_side.value()))))}; 
 auto const l_h {std::max<cpp2::i16>(1, cpp2::i16(std::lround(float(cpp2::move(l_limit.value()) * h) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(float(cpp2::move(l_limit.value()) * h)),cpp2::move(longer_side.value())))))}; 

 auto l {std::vector<float>(w * h)}; // luminance
 auto p {std::vector<float>(w * h)}; // yellow - blue
 auto q {std::vector<float>(w * h)}; // red - green
 auto a {std::vector<float>(w * h)}; 
{
cpp2::i32 i{0};// alpha

 // Convert the image from RGBA to LPQA (composite atop the average color)

 for( ; cpp2::impl::cmp_less(i * 4,CPP2_UFCS(ssize)(rgba)); ++i ) {
  auto pixel {CPP2_UFCS(subspan)(rgba, i * 4, 4)}; 
  auto alpha {CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 3) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 3)),255.f)}; 

  auto r {avg_r * (1.f - alpha) + CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 0) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 0)),255.f) * alpha}; 
  auto g {avg_g * (1.f - alpha) + CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 1) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(pixel, 1)),255.f) * alpha}; 
  auto b {avg_b * (1.f - alpha) + CPP2_ASSERT_IN_BOUNDS_LITERAL(cpp2::move(pixel), 2) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(CPP2_ASSERT_IN_BOUNDS_LITERAL(cpp2::move(pixel), 2)),255.f) * alpha}; 

  CPP2_ASSERT_IN_BOUNDS(l, i) = (r + g + b) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF((r + g + b)),3.f);
  CPP2_ASSERT_IN_BOUNDS(p, i) = (r + g) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF((r + g)),2.f) - cpp2::move(b);
  CPP2_ASSERT_IN_BOUNDS(q, i) = cpp2::move(r) - cpp2::move(g);
  CPP2_ASSERT_IN_BOUNDS(a, i) = cpp2::move(alpha);
 }
}

 // Encode using the DCT into DC (constant) and normalized AC (varying) terms
 auto dct_l {encode_channel(cpp2::move(l), w, h, std::max<cpp2::i16>(3, l_w), std::max<cpp2::i16>(3, l_h))}; 
 auto dct_p {encode_channel(cpp2::move(p), w, h, 3, 3)}; 
 auto dct_q {encode_channel(cpp2::move(q), w, h, 3, 3)}; 

 auto dct_a_dc {1.f}; 
 auto dct_a_ac {std::vector<float>()}; 
 auto dct_a_scale {1.f}; 

 if (has_alpha) {
  // very meh, either declare a common return type with defaults, or beg for structured bindings
  // or use tuples?
  auto dct_a {encode_channel(cpp2::move(a), w, h, 5, 5)}; 
  dct_a_dc = dct_a.dc;
  dct_a_ac = dct_a.ac;
  dct_a_scale = cpp2::move(dct_a).scale;
 }

 auto const is_landscape {cpp2::impl::cmp_greater(w,h)}; 

 cpp2::u32 const header24 {
  (cpp2::u32(std::lround(63.f * dct_l.dc)) << 0) | 
  (cpp2::u32(std::lround(31.5f + 31.5f * dct_p.dc)) << 6) | 
  (cpp2::u32(std::lround(31.5f + 31.5f * dct_q.dc)) << 12) | 
  (cpp2::u32(std::lround(31.0f * dct_l.scale)) << 18) | 
  (cpp2::u32(has_alpha) << 23)}; 

 cpp2::impl::deferred_init<cpp2::u16> landscape_l; 
 if (is_landscape) {
  landscape_l.construct(cpp2::move(l_h));
 }else {
  landscape_l.construct(cpp2::move(l_w));
 }

 cpp2::u16 const header16 {
  cpp2::move(landscape_l.value()) | 
  (cpp2::u16(std::lround(63.f * dct_p.scale)) << 3) | 
  (cpp2::u16(std::lround(63.f * dct_q.scale)) << 9) | 
  (cpp2::u16(cpp2::move(is_landscape)) << 15)}; 

 auto hash {std::vector<cpp2::u8>()}; 
 CPP2_UFCS(reserve)(hash, 25);
 CPP2_UFCS(push_back)(hash, cpp2::u8((header24 >> 0) & 0xff));
 CPP2_UFCS(push_back)(hash, cpp2::u8((header24 >> 8) & 0xff));
 CPP2_UFCS(push_back)(hash, cpp2::u8((cpp2::move(header24) >> 16) & 0xff));
 CPP2_UFCS(push_back)(hash, cpp2::u8((header16 >> 0) & 0xff));
 CPP2_UFCS(push_back)(hash, cpp2::u8((cpp2::move(header16) >> 8) & 0xff));

 if (has_alpha) {
  CPP2_UFCS(push_back)(hash, 
   (cpp2::u8(std::lround(15.f * cpp2::move(dct_a_dc))) << 0) | 
   (cpp2::u8(std::lround(15.f * cpp2::move(dct_a_scale))) << 4)
  );
 }

 auto is_odd {false}; 

 for ( auto const& ac : { cpp2::move(dct_l).ac, cpp2::move(dct_p).ac, cpp2::move(dct_q).ac } ) {
  for ( auto const& f : ac ) {
   auto const v {cpp2::u8(std::lround(15.f * f))}; 
   if (is_odd) {
    CPP2_UFCS(back)(hash) |= cpp2::move(v) << 4;
   }else {
    CPP2_UFCS(push_back)(hash, cpp2::move(v));
   }
   is_odd = !(is_odd);
  }
 }
 if (cpp2::move(has_alpha)) {
  for ( auto const& f : cpp2::move(dct_a_ac) ) {
   auto const v {cpp2::u8(std::lround(15.f * f))}; 
   if (is_odd) {
    CPP2_UFCS(back)(hash) |= cpp2::move(v) << 4;
   }else {
    CPP2_UFCS(push_back)(hash, cpp2::move(v));
   }
   is_odd = !(is_odd);
  }
 }

 return hash; 
}

[[nodiscard]] auto hash_to_aspect_ratio(cpp2::impl::in<std::span<cpp2::u8 const>> hash) -> float{
 if (cpp2::impl::cmp_less(CPP2_UFCS(ssize)(hash),5)) {
  return 0.f; 
 }

 auto const has_alpha {(CPP2_ASSERT_IN_BOUNDS_LITERAL(hash, 2) & 0x80) != 0}; 
 cpp2::impl::deferred_init<cpp2::i32 const> l_max; 
 if (cpp2::move(has_alpha)) {
  l_max.construct(5);
 }else {
  l_max.construct(7);
 }
 cpp2::i32 const l_min {CPP2_ASSERT_IN_BOUNDS_LITERAL(hash, 3) & 7}; 

 auto const is_landscape {(CPP2_ASSERT_IN_BOUNDS_LITERAL(hash, 4) & 0x80) != 0}; 

 cpp2::impl::deferred_init<cpp2::i32 const> lx; 
 if (is_landscape) {
  lx.construct(l_max.value());
 }else {
  lx.construct(l_min);
 }
 cpp2::impl::deferred_init<cpp2::i32 const> ly; 
 if (cpp2::move(is_landscape)) {
  ly.construct(cpp2::move(l_min));
 }else {
  ly.construct(cpp2::move(l_max.value()));
 }

 return float(cpp2::move(lx.value())) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(float(cpp2::move(lx.value()))),float(cpp2::move(ly.value()))); 
}

}

#endif
