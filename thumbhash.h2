
thumbhash: namespace = {

rgba_to_thumb_hash: (rgba: std::span<const u8>, w: i16, h: i16) -> std::vector<u8> = {
	// TODO: do the same 100x100 max as ref?

	assert(rgba.size() == w * h * 4);
	assert(!rgba.empty());

	// avg color
	avg_r := 0.0f;
	avg_g := 0.0f;
	avg_b := 0.0f;
	avg_a := 0.0f; // not avg but sum

	{
		i: i32 = 0;
		while i < rgba.ssize() next i += 4 {
			pixel := rgba.subspan(i, 4);
			alpha := pixel[3] / 255.f;
			avg_r += (pixel[0] / 255.f) * alpha;
			avg_g += (pixel[1] / 255.f) * alpha;
			avg_b += (pixel[2] / 255.f) * alpha;
			avg_a += alpha;
		}
	}

	if avg_a > 0.f {
		avg_r /= avg_a;
		avg_g /= avg_a;
		avg_b /= avg_a;
	}

	std::cout << "avg r:(avg_r)$ g:(avg_g)$ b:(avg_b)$ a:(avg_a)$\n";

	has_alpha : const bool = avg_a < w * h;
	l_limit : const i16;
	if has_alpha {
		l_limit = 5;
	} else {
		l_limit = 7;
	}

	longer_side : const i16;
	if w >= h {
		longer_side = w;
	} else {
		longer_side = h;
	}

	l_w : const = std::max<i16>(1, i16(std::round(float(l_limit * w) / longer_side)));
	l_h : const = std::max<i16>(1, i16(std::round(float(l_limit * h) / longer_side)));

	l := std::vector<float>(w*h); // luminance
	p := std::vector<float>(w*h); // yellow - blue
	q := std::vector<float>(w*h); // red - green
	a := std::vector<float>(w*h); // alpha

	// Convert the image from RGBA to LPQA (composite atop the average color)
	{
		i: i32 = 0;
		while i*4 < rgba.ssize() next i++ {
			pixel := rgba.subspan(i*4, 4);
			alpha := pixel[3] / 255.f;

			r := avg_r * (1.f - alpha) + pixel[0]/255.f * alpha;
			g := avg_g * (1.f - alpha) + pixel[1]/255.f * alpha;
			b := avg_b * (1.f - alpha) + pixel[2]/255.f * alpha;

			l[i] = (r + g + b) / 3.f;
			p[i] = (r + g) / 2.f - b;
			q[i] = r - g;
			a[i] = alpha;
		}
	}


	return ();
}

} // thumbhash

